# -*- coding: utf-8 -*-
"""
Created on Sat Sep  2 11:14:53 2023

Convolutional neural network model setup and training, based on Keras/Tensorflow machine learning framework.

Functions in this script are called by IIMCNNRun.py to solve the Inverse Ising Problem.  

Functions:
createModel():  set up the CNN model with 2 chanels in input data, 4 convolutional + maxpooling layers, 
                followed by fully connected layers with dropout for overfitting prevention.

LoadData(): load full year of training inputs data from ..\\IIMParamGen\\IIMParamGen_{:s}.json. 

CNNTrain(): Train the CNN model to find the Ising parameters, save the model
            The trained model is saved in "IIM_CNN_modelxx"

SinglePeriodGen(): Generate traning data for a single period.
                   Save the metropolis results ..\\IIMParamGen\\IIMParamGen_{:s}.json. 

MultiPeriodGen(): Generate traning data for multi periods of a full year. 
                  These are used as inputs for CNN model training.

YMD_start(): Auxiliary function to return the start date of all periods of a year

YMD_end(): Auxiliary function to return the start date of all periods of a year

@author: Ellen Wang
"""

import numpy as np
import json
import datetime
from numpy import random
from sklearn.model_selection import train_test_split
import tensorflow as tf
import keras
import matplotlib.pyplot as plt
import multiprocessing as mp
import time
import sys
if( "D:\\Users\\ellenwang\\source\\py\\ICEIsing" not in sys.path ): 
    sys.path.append( "D:\\Users\\ellenwang\\source\\py\\ICEIsing" )

from ReadSeaIce import read_SI
from IIMSimul import IIM_period_test
from IIMConstants import v1, v2, NX, NY, metrosteps, NumParam
import IceIsingCont as IIMC # Ice Ising Model Continuous

random.seed(34871234)

# formatting templates
ymd = "{:4d}_{:02d}_{:02d}"
param_fmt = "{:04.2f}_{:04.2f}_{:04.2f}_{:05.2f}_{:05.2f}"
off = '..\\IIMParamGen\\IIMParamGen_{:s}.json'


# set up the CNN model
# 4 convo + maxpooling layers, followed by fully connected layers
def createModel():
    # shape of the CNN model inputs
    image_shape = (NX, NY, 2)

    input_img = tf.keras.Input(image_shape)

    f = tf.keras.layers.Conv2D(16, (3, 3), (1, 1), padding="same", 
                               activation=keras.layers.LeakyReLU(alpha=0.3) )(input_img)
    f = tf.keras.layers.MaxPooling2D(pool_size=(2, 2))(f)    
    f = tf.keras.layers.Conv2D(32, (3, 3), (1, 1), padding="same", 
                               activation=keras.layers.LeakyReLU(alpha=0.3) )(f)
    f = tf.keras.layers.MaxPooling2D(pool_size=(2, 2))(f)    
    f = tf.keras.layers.Conv2D(64, (3, 3), (1, 1), padding="same", 
                               activation=keras.layers.LeakyReLU(alpha=0.3) )(f)
    f = tf.keras.layers.MaxPooling2D(pool_size=(2, 2))(f)    
    f = tf.keras.layers.Conv2D(128, (3, 3), (1, 1), padding="same", 
                               activation=keras.layers.LeakyReLU(alpha=0.3) )(f)
    f = tf.keras.layers.MaxPooling2D(pool_size=(2, 2))(f)    

    f = tf.keras.layers.Flatten()(f)
    f = tf.keras.layers.Dense(100, activation=keras.layers.LeakyReLU(alpha=0.3) )(f)

    f = tf.keras.layers.Dropout(0.2)(f)

    output = tf.keras.layers.Dense(NumParam, activation = 'linear')(f)

    model = tf.keras.Model([input_img], [output])

    opt = tf.keras.optimizers.Adam(learning_rate=0.0001)
    model.compile(optimizer=opt, loss='mse' )

    model.summary()
    return model

# start date of periods for Ising model study, from 16Jun to 16Dec
def YMD_start( year = 2023 ):
    ymds = [] # period start date
    endmonth = 13
    for m in range( 7, endmonth):
        ymds.append((year,m-1,16))
        ymds.append((year,m,1))
    ymds.append((year,m,16))
    return ymds

# end date of periods for Ising model study, starting from 1Jul to 1Jan
def YMD_end( year = 2023 ):
    ymds = [] # period end date
    endmonth = 13
    for m in range( 7, endmonth):
        ymds.append((year,m,1))
        ymds.append((year,m,16))
    ymds.append((year+1,1,1))
    return ymds


# load annual traning data which are generated by IIMParamGen.py
def LoadData( year=2022 ):                     
    data = {}
    ymds = YMD_start(year)

    for y1, m1, d1 in ymds:        
        ymd1 = ymd.format(y1, m1, d1)
        of = off.format( ymd1 )    
        print( "loading ", of )
        with open( of, "r") as openfile:
            jso = json.load(openfile)                                    
        data.update(jso) # append this period to data
    return( data )


# train CNN model and save in file
def CNNTrain( year = 2022, saveModel = True, modelNum = 999, check = True ):
    data = LoadData( year )
        
    # set up training data
    # each X contains 2 channels which are the images of the initial and end state
    # Y are the Ising parameters
    X = []
    Y = []
    for dd, vv in data.items():
        y1,m1,d1 = dd.split('_')
        y1 = int(y1)
        m1 = int(m1)
        d1 = int(d1)
        
        s1 = read_SI( y1, m1, d1) # initil state
        for param_str, s2 in vv.items():        
            params = param_str.split( '_' )
            params = [ float(x) for x in params ]
            if( True ):
                s2 = np.array(s2)
                X.append(np.stack((s1,s2), axis=-1))
                Y.append( np.array(params) )        
    
                # show some training samples, every one out of 10,000 samples
                if( random.random() > 0.9999 ):
                    fig, ax = plt.subplots(1,2)
                    ax[0].imshow( s1, cmap="Blues", vmin=v1, vmax=v2 )
                    ax[1].imshow( s2, cmap="Blues", vmin=v1, vmax=v2 )
                    ax[0].set_title('(a)', y = -0.18)
                    ax[1].set_title('(b)', y = -0.18)
                    fig.suptitle( dd + "   " + param_str )
                    plt.show()
    
    del data # free memory
        
    model = createModel()
    
    # plot the model architecture and save as picture
    keras.utils.plot_model(model, to_file="IIM_CNN.png", show_shapes=True, 
                           show_layer_names=True, show_layer_activations=True, 
                           show_trainable=False)
    
    # split train and test data. We don't need a lot of testing data here
    split = train_test_split(X, Y, test_size=0.01, random_state=42)
    (trainX, testX, trainY, testY) = split
    
    trainsz = len(trainX)
    testsz = len(testX)
    
    trainX = np.array(trainX).reshape((trainsz, NX, NY, 2))
    trainY = np.array(trainY)
    testX = np.array(testX).reshape((testsz, NX, NY, 2))
    testY = np.array(testY)
       
    # print some stats for debugging purpose only 
    print( "size of training data: ", trainsz )
    print( "size of testing data: ", testsz )
    
    print( trainX.shape )
    print( trainY.shape )
    
    print("[INFO] training model...")
    
    # Model fitting
    history = model.fit( x=trainX, y=trainY, 
        validation_data=(testX, testY), 
        epochs=20, batch_size=100, verbose = 1 )
    
    # plot model loss history, for debugging purpose only
    plt.plot(history.epoch, history.history['loss'], color = 'blue', label = 'train')
    plt.plot(history.epoch, history.history['val_loss'], color = 'red', label = 'val')
    plt.legend()
    plt.title('loss')
    plt.show()
    
    # save the model so we can reuse the model later without re-training
    if( saveModel ):
        model.save( "IIM_CNN_model{:d}".format(modelNum) )
          
    # The following code is for debug purpose only
    # to check how the CNN model predicted parameters match with actual data
    ymdf = "{:4d}_{:02d}_{:02d} to {:4d}_{:02d}_{:02d}"    
    if( check ):
        # the below code check all periods of 2023, but you can check choose to check a single period of course
        ymd1 = YMD_start(year)
        ymd2 = YMD_end(year)
            
        sz = len(ymd1)
        for i in range(sz):
            y1, m1, d1 = ymd1[i]
            y2, m2, d2 = ymd2[i]
            s1 = read_SI( y1, m1, d1)
            s2 = read_SI( y2, m2, d2)
            print( "start", y1, m1, d1 )
            print( "end", y2, m2, d2 )    
    
            s = np.stack((s1,s2), axis=-1)
            s = np.array(s).reshape((1, NX, NY, 2))        
    
            param_ch = model.predict( s )
            param_ch = param_ch.reshape( NumParam )        
            ymd_str = ymdf.format(y1,m1,d1,y2,m2,d2)
            param_str = param_fmt.format(param_ch[0],param_ch[1],param_ch[2],param_ch[3],param_ch[4])
            
            # IIM_period_test displays 3 images for each period so we can visualize how the model works for each period
            # 3 images: the initial lattice, the target end lattice and the CNN predicted target end lattice
            d, s1_outs = IIM_period_test( param_ch, args = [s1, s2, NX, NY], plt_title=ymd_str+"\n"+param_str)
    

# Generate traning data for a single period, and save the metropolis results 
def SinglePeriodGen( dd, NN=10000, savefile = True ):
    if( dd==datetime.date(2022, 11, 9) ): # 9Nov2022 NSIDC data missing
        return
    
    # NN = 10000 # number of training data for each period start date
    y1 = dd.year
    m1 = dd.month
    d1 = dd.day
        
    ymd1 = ymd.format(y1, m1, d1)
    # bnd = all_bnds[ ymd1 ]

    # param for melting cycles
    bnds1 = [ (2.25, 2.75), 
            (2, 9), # positive B0, more data
            (-10, 0),
            (-10, 10), 
            (9, 11)] 
        
    # param for freezing cycles
    bnds2 = [ (2.25, 2.75), 
            (-15, -9), # negative
            (-10, -1),
            (-10, 10), 
            (9, 11)]     
    if( m1<9 or ( m1==9 and d1<15) ):
        bnd = bnds1
    else:
        bnd = bnds2
        
    res = {}

    res[ ymd1 ] = {}
    s1 = read_SI( y1, m1, d1)
    
    p = np.zeros(NumParam)
    
    for i in range(NN):
        for j in range( NumParam ):
            p[j] = random.uniform(bnd[j][0], bnd[j][1] )
            
        param_str = param_fmt.format( p[0], p[1], p[2], p[3], p[4])
        ice_im = IIMC.Lattice(s1, NX = NX, NY = NY, J=p[0], B=p[1], Bx=p[2], By=p[3] ) 
        ice_im.metropolis( metrosteps, p[4] )
        s1_out = [ [ round(0.5+x/2,3)  for x in line ] for line in ice_im.lat ]
        # plt.imshow(s1_out, cmap="Blues", vmin=v1, vmax=v2)
        res[ ymd1 ][param_str] = s1_out
        
    if(savefile):        
        of = off.format( ymd1 )    
        # res = {"date": (y1,m1,d1), 
        #        "param": params.tolist(),
        #        "out": s1_out}
        with open( of, "w") as outfile:
            json.dump( res, outfile, indent = 2)    


# Generate traning data for multi periods of a full year, which will be used as inputs for CNN model training
def MultiPeriodGen( year = 2022, NN=10000, savefile=True, loadfile=True ):
    # NN is number of training samples to be generated for each period
    # savefile: whether to save the generated training samples
    # loadfile: whether load the generated traning samples, for debug purpose only

    ymds = YMD_start(year)
    sz = len(ymds)

    th=[]
    for y1,m1,d1 in ymds:        
        dd = datetime.date( y1,m1,d1 )
        th.append( mp.Process( target = SinglePeriodGen, args = [dd, NN, savefile] ) )

    starttime = time.time()
    for i in range(sz):
        th[i].start()

    for i in range(sz):
        th[i].join()

    endtime = time.time()
    print("execution time is:%6.0f seconds" % (endtime - starttime) )

    # Testing to load the generated training data for one of the periods, debug purpose only
    if( loadfile ):
        ymd1 = ymd.format( ymds[0][0] , ymds[0][1], ymds[0][2])
        of = off.format( ymd1 )    
        with open( of, "r") as openfile:
            jso = json.load(openfile)
        # print the loaded data - for debugging purpose only
        print( of, len(jso[ymd1]) )

